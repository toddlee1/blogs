---
layout: post
title:  "Chapter 5: 모던 동시성 - 코루틴(Coroutines)"
---
# Chapter 5: 모던 동시성 - 코루틴(Coroutines)

현대 웹 애플리케이션은 여러 API를 동시에 호출하거나, 오래 걸리는 작업을 백그라운드에서 처리하는 등 비동기/동시성 처리가 필수적입니다. 하지만 콜백 지옥(Callback Hell), 복잡한 스레드 관리 등 기존 방식은 코드를 이해하고 유지보수하기 어렵게 만들었습니다.

Kotlin 코루틴은 이러한 문제를 해결하기 위해 등장한 언어 수준의 솔루션입니다. 비동기 코드를 마치 동기 코드처럼 쉽고 직관적으로 작성할 수 있게 해줍니다. Spring Boot 2.2부터는 코루틴을 공식 지원하여, 이제 손쉽게 프로젝트에 적용할 수 있습니다.

---

### 1. `suspend` 함수: 비동기 코드를 동기 코드처럼

코루틴의 핵심은 `suspend` (일시 중단) 변경자입니다. 함수에 `suspend`를 붙이면, 해당 함수는 **스레드를 차단(Blocking)하지 않고 작업을 잠시 '일시 중단'** 할 수 있는 특별한 함수가 됩니다.

예를 들어, 외부 API를 호출하거나 데이터베이스 쿼리를 실행하는 동안, 함수는 실행을 잠시 멈추고 자신을 실행하던 스레드를 다른 작업에 양보합니다. 작업이 완료되면, 멈췄던 지점부터 실행을 재개합니다. 개발자 입장에서는 일반적인 동기 코드처럼 순서대로 코드를 작성하면 끝!

**예시: 다른 서비스의 API를 호출하여 내 정보와 합치기**

```kotlin
// 외부 서비스 API를 호출하는 가상 클라이언트
interface UserApiClient {
    // 이 함수는 네트워크 통신이 필요하므로 suspend 함수로 정의
    suspend fun getUserInfo(userId: String): UserInfo
}

@Service
class MyService(
    private val myRepository: MyRepository,
    private val userApiClient: UserApiClient
) {
    // 이 함수도 내부에서 suspend 함수를 호출하므로, 반드시 suspend로 선언해야 함
    suspend fun getMyAggregatedInfo(userId: String): AggregatedInfo {
        
        // 1. 내 데이터베이스에서 내 정보 조회 (I/O 작업)
        val myInfo = myRepository.findByUserId(userId) // 이것도 suspend 함수라고 가정
        
        // 2. 외부 API에서 사용자 정보 조회 (네트워크 I/O 작업)
        val userInfo = userApiClient.getUserInfo(userId) // suspend 함수 호출
        
        // 3. 두 정보를 조합하여 반환
        // 개발자는 위 코드들이 순서대로 실행된다고 생각하고 코딩하면 끝!
        // 실제로는 각 작업이 스레드를 블로킹하지 않고 효율적으로 실행됨
        return AggregatedInfo(myInfo, userInfo)
    }
}
```

---

### 2. 구조화된 동시성 (Structured Concurrency)

코루틴은 `coroutineScope` 빌더를 통해 **구조화된 동시성**이라는 강력한 개념을 제공합니다. 이는 시작한 모든 코루틴 작업이 해당 스코프가 끝나기 전에 완료되도록 보장하는 메커니즘입니다.

만약 스코프 내에서 여러 개의 비동기 작업을 시작했다면, 그중 하나라도 실패할 경우 나머지 모든 작업들이 자동으로 취소됩니다. 이를 통해 작업 누수(leak)를 방지하고, 자원을 안전하게 관리하며, 부모-자식 관계의 작업들을 명확하게 추적할 수 있습니다.

**예시: 여러 정보를 동시에 가져와 합치기**

```kotlin
suspend fun getPostWithDetails(postId: Long): PostDetails {
    // coroutineScope 블록: 이 안의 모든 작업이 끝나야 다음으로 진행
    return coroutineScope {
        // async: 코루틴을 시작하고 Deferred(결과를 나중에 받을 수 있는 약속)를 반환
        val postDeferred = async { postRepository.findById(postId) }
        val commentsDeferred = async { commentRepository.findByPostId(postId) }
        
        // await(): Deferred의 결과가 준비될 때까지 기다림 (suspend)
        val post = postDeferred.await()
        val comments = commentsDeferred.await()
        
        // 두 작업이 모두 성공적으로 끝나야 이 지점에 도달
        PostDetails(post, comments)
    } // 만약 위 작업 중 하나라도 실패하면, 다른 하나는 자동으로 취소되고 예외가 발생
}
```

---

### 3. Spring Boot와 코루틴의 완벽한 통합

Spring WebFlux가 아닌 전통적인 Spring Web(MVC)에서도 코루틴을 완벽하게 사용할 수 있습니다. 컨트롤러의 메소드에 `suspend` 키워드를 붙이기만 하면 됩니다.

Spring은 해당 요청을 서블릿 스레드에서 분리하여 코루틴 컨텍스트에서 실행하고, 모든 `suspend` 작업이 완료되면 다시 서블릿 스레드로 응답을 보냅니다. 적은 수의 스레드로도 많은 동시 요청을 효율적으로 처리할 수 있게 됩니다.

**예시: `suspend` 컨트롤러 메소드**

```kotlin
import kotlinx.coroutines.delay
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RestController

@RestController
class CoroutineController {

    // 컨트롤러 메소드에 바로 suspend 키워드를 사용
    @GetMapping("/hello-coroutine")
    suspend fun hello(): String {
        // 스레드를 블로킹하지 않고 1초 동안 대기
        delay(1000) 
        return "Hello, from coroutine!"
    }
}
```
이처럼 Kotlin 코루틴은 Spring Boot 애플리케이션의 성능과 코드 품질을 한 단계 끌어올릴 수 있는 강력하고 현대적인 동시성 처리 솔루션입니다. 