---
layout: post
title:  "Chapter 3: 데이터베이스 마스터하기 - 확장 함수와 DSL"
---
# Chapter 3: 데이터베이스 마스터하기 - 확장 함수와 DSL

데이터를 다루는 것은 백엔드 애플리케이션의 핵심입니다. Spring Data JPA는 매우 편리한 데이터베이스 접근 기술이지만, Kotlin과 함께 사용할 때는 몇 가지 주의점이 필요합니다. 이번 챕터에서는 Kotlin의 특성을 활용하여 JPA 코드를 한 단계 업그레이드하는 방법을 알아봅니다.

---

### 1. Entity에 `data class`를 쓰면 안 되는 이유

`data class`는 DTO에겐 축복이지만, JPA Entity에겐 재앙이 될 수 있습니다. 이유는 JPA와 `data class`의 동작 방식이 충돌하기 때문입니다.

- **`toString()` 문제:** `data class`가 자동 생성하는 `toString()`은 모든 프로퍼티를 출력합니다. 만약 Entity 간에 양방향 연관관계(예: `Post`와 `Comment`)가 설정되어 있다면, `toString()` 호출 시 서로를 무한히 참조하며 `StackOverflowError`를 발생시킬 수 있습니다.
- **`equals()` & `hashCode()` 문제:** `data class`의 `equals`와 `hashCode`는 모든 프로퍼티를 비교합니다. 하지만 JPA의 지연 로딩(Lazy Loading) 때문에, 아직 로드되지 않은 연관관계 필드는 `Proxy` 객체로 존재합니다. 이 상태에서 `equals` 비교를 하면, 프록시 객체의 특성 때문에 예상치 못한 결과를 낳을 수 있습니다.
- **JPA 스펙:** JPA 표준은 Entity 클래스가 `final`이 아니어야 하고, 기본 생성자(argument-less constructor)를 가져야 한다고 명시합니다. `data class`는 기본적으로 `final`이고, 모든 프로퍼티를 포함하는 생성자만 만듭니다. (물론 `all-open` 같은 플러그인으로 해결할 수는 있습니다.)

**올바른 Entity 설계:**

가장 좋은 방법은 일반 `class`를 사용하고, 필요한 프로퍼티만 직접 정의하는 것입니다.

```kotlin
import javax.persistence.*

@Entity
class Post(
    @Column(nullable = false)
    var title: String,

    @Lob
    @Column(nullable = false)
    var content: String,
    
    // ... 다른 필드들 ...
) {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long = 0
}
```
`id`를 `val`로 선언하여 불변으로 만들고, 나머지 필드는 JPA가 값을 변경할 수 있도록 `var`로 선언하는 것이 일반적입니다.

---

### 2. 확장 함수 (Extension Functions)로 Repository 기능 강화

"조회했는데 없으면 예외를 던져라" 같은 코드는 매우 자주 사용됩니다. Spring Data JPA의 `findById`는 `Optional`을 반환하므로, 매번 `.orElseThrow()`를 호출해야 합니다.

Kotlin의 **확장 함수**를 이용하면, 마치 `PostRepository`에 원래부터 그런 메소드가 있었던 것처럼 새로운 기능을 추가할 수 있습니다.

**예시: `findByIdOrThrow` 확장 함수 만들기**

```kotlin
// PostRepository.kt
import org.springframework.data.jpa.repository.JpaRepository

interface PostRepository : JpaRepository<Post, Long> {
    // 기본 기능만 정의
}

// PostRepositoryExtensions.kt
import org.springframework.data.repository.findByIdOrNull // Spring-data-commons 2.2 부터 기본 제공

// PostRepository에 findByIdOrThrow 라는 새로운 함수를 '확장'
fun PostRepository.findByIdOrThrow(id: Long): Post {
    return this.findByIdOrNull(id)
        ?: throw EntityNotFoundException("해당 ID의 게시글을 찾을 수 없습니다: $id")
}


// PostService.kt 에서 사용
fun getPost(id: Long): PostResponse {
    // 이제 orElseThrow 없이 바로 호출 가능! 코드가 훨씬 깔끔해진다.
    val post = postRepository.findByIdOrThrow(id)
    return PostResponse(post.id, post.title, post.content)
}
```
`this`는 확장 함수를 호출한 객체, 즉 `postRepository` 인스턴스를 가리킵니다. 이제 프로젝트 어디서든 `PostRepository`를 주입받아 `findByIdOrThrow`를 바로 사용할 수 있습니다.

---

### 3. QueryDSL로 타입-세이프(Type-safe)한 동적 쿼리 작성

문자열을 조합하여 쿼리를 만드는 방식은 오타에 취약하고 컴파일 시점에 오류를 잡을 수 없습니다. QueryDSL은 코틀린 코드를 통해 SQL 쿼리를 작성하게 해주어, 컴파일 시점에 타입과 문법 오류를 모두 잡을 수 있는 강력한 도구입니다.

Kotlin과 함께 사용하면 그 장점이 극대화됩니다.

**예시: 키워드와 카테고리로 게시글 검색 (일부)**

```kotlin
// PostCustomRepositoryImpl.kt
import com.querydsl.jpa.impl.JPAQueryFactory

class PostCustomRepositoryImpl(
    private val queryFactory: JPAQueryFactory
) : PostCustomRepository {
    
    // QPost는 QueryDSL이 컴파일 시점에 자동 생성해주는 클래스
    private val post = QPost.post 

    override fun search(keyword: String?, category: String?): List<Post> {
        return queryFactory
            .selectFrom(post)
            .where(
                keywordContains(keyword),   // 동적으로 where 조건 조합
                categoryEquals(category)
            )
            .fetch()
    }

    private fun keywordContains(keyword: String?) = 
        keyword?.let { post.title.contains(it).or(post.content.contains(it)) }

    private fun categoryEquals(category: String?) = 
        category?.let { post.category.name.eq(it) }
}
```
`where` 절 안에서 `keyword`나 `category`가 `null`이면 해당 조건문은 무시됩니다. Kotlin의 `let` 함수와 결합하여 매우 간결하고 안전하게 동적 쿼리를 구현할 수 있습니다. 