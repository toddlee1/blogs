---
layout: custom-post
title:  "Chapter 2: 안전한 설계의 핵심 - Null과의 전쟁"
---

`NullPointerException`(NPE)은 Java 개발자를 가장 괴롭히는 예외 중 하나입니다. Kotlin은 타입 시스템을 통해 이 문제를 컴파일 시점에서 원천적으로 차단하도록 설계되었습니다. Spring의 Service 계층과 의존성 주입(DI) 과정에서 Kotlin의 Null Safety 기능을 어떻게 활용하여 버그 없는 안전한 코드를 만들 수 있는지 알아봅시다.

---

### 1. Nullable 타입 (`?`) vs Non-null 타입

Kotlin은 모든 타입을 기본적으로 **Null을 허용하지 않는(Non-null)** 타입으로 다룹니다. 만약 변수에 `null`을 담을 수 있게 하려면, 타입 뒤에 물음표(`?`)를 명시적으로 붙여주어야 합니다.

이 간단한 규칙 덕분에, 우리는 어떤 변수가 `null`이 될 가능성이 있는지, 없는지를 코드를 보는 즉시 파악할 수 있으며, 컴파일러는 `Non-null` 타입의 변수에 `null`을 할당하려는 시도를 막아줍니다.

**예시: 사용자 프로필 조회**

```kotlin
class UserProfile(
    val nickname: String,       // null이 될 수 없음
    val profileImageUrl: String?  // 프로필 이미지는 없을 수도 있음 (null 가능)
)

fun printNickname(nickname: String) {
    println("닉네임: $nickname")
}

val user = UserProfile("코틀링고", null)

printNickname(user.nickname) // OK. nickname은 절대 null이 아님을 컴파일러가 보장
// printNickname(user.profileImageUrl) // 컴파일 에러! null일 수 있는 값을 null을 허용하지 않는 파라미터에 넘길 수 없음
```

---

### 2. 생성자 주입 (Constructor Injection)이 정답인 이유

Spring에서 의존성을 주입하는 방법은 크게 필드 주입, 수정자 주입, 생성자 주입 세 가지가 있습니다. Kotlin 환경에서는 **생성자 주입**이 거의 유일한 정답에 가깝습니다.

- **불변성(Immutability):** `val`로 선언된 의존성은 앱이 실행되는 동안 절대 변경되지 않음을 보장합니다.
- **Null-Safety:** 의존성이 `Non-null` 타입으로 선언되면, Spring 컨테이너는 이 객체를 생성할 때 해당 의존성이 반드시 주입되어야 함을 보장합니다. 만약 의존성을 찾지 못하면 앱 실행 자체가 실패하므로, 런타임에 의존성이 `null`이 되어 발생하는 NPE를 원천적으로 방지합니다.
- **테스트 용이성:** 의존성을 생성자에서 직접 전달받으므로, 단위 테스트 시 Mock 객체를 주입하기 매우 편리합니다.

**예시: `PostService`에 `PostRepository` 주입**

```kotlin
// PostService.kt
import org.springframework.stereotype.Service

@Service
class PostService(
    private val postRepository: PostRepository // 생성자를 통해 Non-null 타입으로 주입
) {
    fun createPost(request: PostCreateRequest): PostResponse {
        // postRepository는 절대 null이 될 수 없으므로, 안심하고 사용 가능
        val savedPost = postRepository.save(...)
        // ...
    }
}
```

---

### 3. `lateinit`의 함정과 올바른 사용법

때로는 생성자에서 즉시 초기화할 수 없는 프로퍼티가 필요할 수 있습니다. 대표적으로 `@Value` 어노테이션으로 외부 설정값을 주입받는 경우입니다. 이때 `lateinit` 변경자를 사용하면, 프로퍼티를 `Non-null` 타입으로 선언하되 초기화는 나중에 하겠다고 컴파일러에게 약속할 수 있습니다.

하지만 `lateinit`은 약속일 뿐입니다. 만약 초기화되기 전에 해당 프로퍼티에 접근하면 `UninitializedPropertyAccessException`이 발생합니다. 따라서 꼭 필요한 경우에만 제한적으로 사용해야 합니다.

**예시: 외부 설정값 주입**

```kotlin
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component

@Component
class FileUploader {

    @Value("\${file.upload-dir}")
    private lateinit var uploadDir: String // 생성자에서 초기화 불가, Spring이 나중에 주입해줌

    fun upload(file: ByteArray) {
        // 이 시점에는 uploadDir이 초기화되었음을 가정하고 사용
        // 만약 초기화되지 않았다면 여기서 Exception 발생
        val path = "$uploadDir/${file.name}"
        // ...
    }
}
```

---

### 4. `?.let`을 활용한 우아한 null 처리

`null`일 수 있는(`Nullable`) 객체에 접근할 때는, Java처럼 `if (obj != null)` 체크를 할 수도 있지만, Kotlin은 더 세련된 방법을 제공합니다. 바로 '안전 호출(`?.`)'과 `let` 스코프 함수를 조합하는 것입니다.

`obj?.let { ... }` 구문은 `obj`가 `null`이 아닐 경우에만 중괄호 `{}` 안의 람다를 실행합니다. 람다 안에서 `obj`는 `it`이라는 이름의 `Non-null` 타입으로 사용되어, 안전하게 프로퍼티나 메소드에 접근할 수 있습니다.

**예시: 선택적 파라미터 처리**

```kotlin
// PostService.kt

// category 파라미터는 null일 수 있음
fun findPosts(category: String?): List<PostResponse> {
    
    // category가 null이 아닐 때만 아래 블록이 실행됨
    category?.let { cat ->
        // 이 블록 안에서 'cat'은 String 타입 (Non-null)
        println("카테고리 '${cat}' 게시글을 검색합니다.")
        // ... 카테고리 필터링 로직 ...
    }
    
    // ... 전체 게시글 검색 또는 필터링된 결과 반환 ...
}
```
이러한 Kotlin의 Null Safety 기능들은 코드를 더 안전하게 만들 뿐만 아니라, 개발자의 의도를 더 명확하게 표현하여 가독성과 유지보수성을 크게 향상시킵니다. 