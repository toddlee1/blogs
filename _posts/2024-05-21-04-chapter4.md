---
layout: post
title:  "Chapter 4: 비즈니스 로직 - 상태와 흐름 제어"
---
# Chapter 4: 비즈니스 로직 - 상태와 흐름 제어

애플리케이션의 핵심 가치는 비즈니스 로직에 있습니다. 복잡하게 얽힌 조건과 다양한 상태를 어떻게 다루느냐가 코드의 품질을 결정합니다. Kotlin은 `if-else`의 장황함을 개선한 `when` 표현식과, 특정 상태들을 '봉인'하여 관리하는 `sealed class`를 통해 이 문제를 우아하게 해결합니다.

---

### 1. `when` 표현식: `if-else`와 `switch`를 넘어서

Java의 `if-else if-else` 체인은 조건이 많아질수록 가독성이 떨어지고, `switch-case`는 기능이 제한적이었습니다. Kotlin의 `when`은 이 둘의 장점을 합치고 더욱 강력한 기능을 제공합니다.

`when`은 값, 타입, 범위 등 다양한 조건으로 분기할 수 있으며, `else`를 통해 모든 경우의 수를 처리하도록 강제할 수 있습니다. 특히 `when`은 단순한 구문(statement)이 아니라 값을 반환하는 **표현식(expression)**이므로, 변수에 직접 결과를 할당할 수 있어 코드가 훨씬 간결해집니다.

**예시: 사용자 등급에 따라 다른 할인율 적용**

```kotlin
// User.kt
enum class UserGrade {
    NORMAL,
    SILVER,
    GOLD,
    VIP
}

class User(val grade: UserGrade, val purchaseAmount: Int)

// DiscountService.kt
fun getDiscountRate(user: User): Double {
    // when 표현식의 결과를 바로 반환 (return)
    return when (user.grade) {
        UserGrade.NORMAL -> 0.0
        UserGrade.SILVER -> 0.05
        UserGrade.GOLD -> {
            // 조건에 따라 블록 내에서 추가 로직 수행 가능
            if (user.purchaseAmount > 1_000_000) {
                0.15
            } else {
                0.10
            }
        }
        UserGrade.VIP -> 0.2
        // enum 클래스와 함께 쓰면 else를 생략해도 컴파일러가 모든 경우를 체크했는지 검사해줌
    }
}
```

---

### 2. `sealed class`: 예측 가능한 상태 머신

API 응답은 성공할 수도, 다양한 종류의 에러가 발생할 수도 있습니다. 이런 '상태'들을 모델링할 때 `sealed class` (봉인된 클래스)를 사용하면 매우 강력한 이점을 얻을 수 있습니다.

`sealed class`는 자기 자신을 상속받는 클래스들을 특정 파일 내로 '봉인'하는 기능입니다. 이렇게 하면, `when` 표현식과 함께 사용될 때 컴파일러가 **정의된 모든 하위 클래스(모든 상태)를 다 처리했는지 검사**해줄 수 있습니다. 만약 새로운 상태(에러 종류)가 추가되었는데 `when`에서 이를 처리하는 코드를 빠뜨렸다면, 컴파일 에러가 발생하여 실수를 사전에 방지할 수 있습니다.

**예시: API 응답 상태 모델링**

```kotlin
// ApiResponse.kt

// ApiResult 라는 상태는 Success, Error, Loading 세 가지로만 '봉인'된다.
sealed class ApiResult<out T> {
    data class Success<out T>(val data: T) : ApiResult<T>()
    data class Error(val code: Int, val message: String) : ApiResult<Nothing>()
    object Loading : ApiResult<Nothing>()
}


// PostController.kt
@GetMapping("/posts/{id}")
fun getPost(@PathVariable id: Long): ResponseEntity<*> {
    val result: ApiResult<PostResponse> = postService.getPost(id)

    // when으로 모든 ApiResult 상태를 처리
    return when (result) {
        is ApiResult.Success -> {
            // 'is'로 타입 체크가 되면, 스마트 캐스팅 덕분에 result를 Success 타입으로 바로 사용 가능
            ResponseEntity.ok(result.data)
        }
        is ApiResult.Error -> {
            ResponseEntity
                .status(result.code)
                .body(result.message)
        }
        is ApiResult.Loading -> {
            // 이 부분을 주석처리하면 컴파일 에러 발생!
            // Error: 'when' expression must be exhaustive
            ResponseEntity.accepted().body("처리 중입니다...")
        }
    }
}
```
`sealed class`를 사용하면 "어떤 종류의 결과가 올 수 있는지"가 코드 자체에 명확하게 문서화되고, 컴파일러의 도움을 받아 잠재적인 버그를 효과적으로 제거할 수 있습니다. 